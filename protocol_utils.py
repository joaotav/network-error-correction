import socket
from binascii import crc32
from random import randint

'''
    Implemented by João Otávio Chervinski - 2018

    The format of the frames used is as follows:
    | Destination MAC (12 bytes) | Source MAC (12 bytes)| Frame number (1 byte)|
    Data (1 - 8128 bytes) | CRC-32 (10 bytes) |
'''

def build_frame(dest, source, frame_number, data):
    ''' Builds the frame fields
    | Destination(12 bytes) | Source (12 bytes)| Frame number (1 byte)| Data(1 - 8128 bytes) | CRC-32(4 bytes) |'''
    frame = ''
    frame += dest # Destination address
    frame += source # Source address
    frame += str(frame_number) # Frame number
    if type(data) == bytes: # If payload is already encoded
        frame += data.decode() # Decode to concatenate with the rest of the frame
    else:
        frame += str(data)

    crc = str(crc32(frame.encode())) # Computes the CRC of the frame data

    if len(crc) < 10: # If the resulting CRC has less than 10 bytes
        padding = 10 - len(crc)
        crc += padding * '0' # Adds padding characters at the end

    frame += crc # CRC
    return frame.encode()


def check_integrity(message):
    ''' Verifies if the CRC received in the frame matches the CRC generated by the remaining data '''
    received_crc = message[-10:] # Gets the last 10 bytes which compose the CRC
    generated_crc = str(crc32(message[:-10].encode())) # Generates the frame's CRC again

    if len(generated_crc) < 10: # If CRC doesn't have 10 bytes
        padding = 10 - len(generated_crc)
        generated_crc += padding * '0' # Adds padding

    if received_crc == generated_crc: # If CRC is the same, the message wasn't corrupted
        return True
    return False


def extract_payload(message):
    ''' Removes control fields and returns the message content '''
    message = message[25:] # Removes the initial headers (destination, source, frame number)
    message = message[:-10] # Removes the CRC
    return message


def recv_message(sock, buffer_size):
    ''' Retrieves message data from the socket and decodes them '''
    message = sock.recv(buffer_size)
    return message.decode()


def get_frame_no(data):
    ''' Returns the received frame number '''
    return int(data[24])


def next_frame(frame_no):
    ''' Advances the frame value to the next in sequence 0-9 '''
    if frame_no < 9:  # If the frame is less than nine, increment
        frame_no += 1
    else:
        frame_no = 0 # If the frame is nine, goes back to 0
    return frame_no


def is_previous_frame(frame_no, ack_no):
    ''' Verifies if the ACK corresponds to the previous frame in sequence '''
    if frame_no > 0:
        if frame_no - 1 == ack_no:
            return True
    elif frame_no == 0 and ack_no == 9:
        return True
    else:
        return False


def induce_errors(frame, probability):
    ''' Creates errors in the frames by changing the CRC field to 0000000000 '''
    frame = frame.decode()
    if frame[24] != '/': # If it's not one of the acknowledgment frames
        chance = randint(1, 100)
        if chance <= probability:
            frame = frame[:-10] # Removes the correct CRC
            frame += '0000000000' # Adds a CRC that will generate an error
    return frame.encode()

